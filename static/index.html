<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NetSim.io - Professional Network Simulation</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üï∏Ô∏è</text></svg>">
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>

    <!-- xterm.js for real terminal emulation -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>

    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">

    <style>
        :root {
            --bg-dark: #020617;
            --bg-panel: rgba(15, 23, 42, 0.8);
            --bg-panel-solid: #0f172a;
            --bg-input: #020617;
            --border: rgba(51, 65, 85, 0.5);
            --primary: #10b981;
            /* Emerald */
            --primary-glow: rgba(16, 185, 129, 0.3);
            --secondary: #6366f1;
            /* Indigo */
            --secondary-glow: rgba(99, 102, 241, 0.3);
            --text-main: #f8fafc;
            --text-mute: #94a3b8;
            --danger: #ef4444;
            --glass-bg: rgba(15, 23, 42, 0.7);
            --glass-border: rgba(255, 255, 255, 0.05);
        }

        * {
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        body {
            margin: 0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Top Navigation Bar */
        #navbar {
            height: 64px;
            background: var(--bg-panel-solid);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 24px;
            justify-content: space-between;
            z-index: 50;
            backdrop-filter: blur(8px);
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 12px;
            font-weight: 800;
            font-size: 20px;
            color: #fff;
            letter-spacing: -0.02em;
        }

        .brand span {
            color: var(--primary);
        }

        .toolbar {
            display: flex;
            gap: 8px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .tool-btn {
            background: transparent;
            border: none;
            color: var(--text-mute);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Inter', sans-serif;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .tool-btn:hover {
            color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }

        .tool-btn.active {
            background: var(--primary);
            color: #000;
            box-shadow: 0 4px 12px var(--primary-glow);
        }

        .tool-btn i {
            font-size: 20px;
        }

        .btn {
            padding: 10px 20px;
            border-radius: 10px;
            border: none;
            font-weight: 700;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: 'Inter', sans-serif;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), #0d9488);
            color: white;
            border: none;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
        }

        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.3);
            filter: brightness(1.1);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border: none;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.2);
            width: 100%;
        }

        .btn-danger:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(239, 68, 68, 0.3);
            filter: brightness(1.1);
        }

        @keyframes pulse-save {
            0% {
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0.4);
            }

            70% {
                box-shadow: 0 0 0 6px rgba(16, 185, 129, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(16, 185, 129, 0);
            }
        }

        .btn-save-anim {
            animation: pulse-save 2s infinite;
        }

        .btn-secondary {
            background: var(--secondary);
            color: #fff;
            box-shadow: 0 8px 20px -8px var(--secondary);
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-main);
        }

        .btn:hover {
            transform: translateY(-1px);
            filter: brightness(1.1);
        }

        /* Main Workspace Layout */
        #workspace {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        /* Network Graph Canvas */
        #network-graph {
            flex: 1;
            background-color: var(--bg-dark);
            /* Grid Pattern */
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 30px 30px;
            position: relative;
        }

        /* Resizers */
        .resizer-v {
            width: 4px;
            cursor: col-resize;
            background: transparent;
            transition: background 0.2s;
            z-index: 100;
        }

        .resizer-v:hover {
            background: var(--primary);
        }

        .resizer-h {
            height: 4px;
            cursor: row-resize;
            background: transparent;
            transition: background 0.2s;
            z-index: 100;
        }

        .resizer-h:hover {
            background: var(--primary);
        }

        /* Palette Sidebar */
        #node-palette {
            width: 64px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 16px;
            padding: 16px 8px;
            z-index: 20;
            overflow-y: auto;
            overflow-x: hidden;
            align-items: center;
            /* Center icons */
        }

        .palette-item {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-mute);
            transition: all 0.2s;
            flex-shrink: 0;
        }

        .palette-item:hover {
            color: #fff;
            border-color: var(--primary);
            background: rgba(255, 255, 255, 0.08);
        }

        /* Tool Tabs */
        .panel-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            background: #111;
        }

        .panel-tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            font-size: 11px;
            font-weight: 700;
            cursor: pointer;
            color: var(--text-mute);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 2px solid transparent;
        }

        .panel-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: var(--bg-panel);
        }

        /* Inspection Tables */
        .inspection-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            margin-top: 10px;
        }

        .inspection-table th {
            text-align: left;
            padding: 4px 8px;
            color: var(--text-mute);
            border-bottom: 1px solid var(--border);
        }

        .inspection-table td {
            padding: 6px 8px;
            border-bottom: 1px solid #1f2229;
        }

        .inspection-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border);
        }

        .inspection-header h4 {
            margin: 0;
            font-size: 11px;
            color: var(--text-mute);
            text-transform: uppercase;
        }

        /* Properties Panel */
        #properties-panel {
            width: 320px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title {
            font-size: 16px;
            font-weight: 700;
            color: #fff;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .node-badge {
            font-size: 10px;
            padding: 4px 8px;
            background: #2a2e35;
            border-radius: 4px;
            color: var(--text-mute);
            font-weight: 600;
            border: 1px solid var(--border);
        }

        .panel-content {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-label {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-mute);
            text-transform: uppercase;
            letter-spacing: 0.8px;
            margin-bottom: 8px;
        }

        .styled-input {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 12px;
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        .styled-input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-mute);
            text-align: center;
            padding: 40px;
        }

        .empty-state i {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.3;
        }

        /* Bottom Terminal Panel */
        #terminal-panel {
            height: 350px;
            background: #000;
            border-top: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            /* Full width overlay */
            transform: translateY(100%);
            /* Hidden by default */
            height: 300px;
            background: rgba(10, 10, 10, 0.98);
            border-top: 2px solid var(--primary);
            display: flex;
            flex-direction: column;
            z-index: 1000;
            box-shadow: 0 -10px 30px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease-out;
            backdrop-filter: blur(10px);
            transform: translateY(100%);
            /* Hidden by default */
        }

        #terminal-panel.open {
            transform: translateY(0);
        }

        .terminal-header {
            background: #111;
            padding: 8px 16px;
            border-bottom: 1px solid #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #aaa;
            user-select: none;
        }

        .terminal-tab {
            color: var(--primary);
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Outfit', sans-serif;
            font-size: 13px;
            letter-spacing: 0.5px;
        }

        .terminal-tab::before {
            content: "";
            width: 10px;
            height: 10px;
            background: #22c55e;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 8px rgba(34, 197, 94, 0.6);
        }

        .terminal-content {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            color: #e2e8f0;
            line-height: 1.5;
            background: #000;
            cursor: text;
        }

        .log-entry {
            margin-bottom: 4px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .prompt {
            color: #4ade80;
            font-weight: 700;
            white-space: nowrap;
            margin-right: 8px;
            /* Standard spacing after prompt */
            text-shadow: 0 0 8px rgba(74, 222, 128, 0.3);
            user-select: none;
            flex-shrink: 0;
            /* Important: Don't let prompt shrink */
        }

        .input-line {
            display: flex;
            width: 100%;
            align-items: baseline;
            /* Align with text baseline */
            margin-top: 4px;
        }

        #console-input {
            flex: 1;
            background: transparent;
            border: none;
            color: #fff;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            outline: none;
            padding: 0;
            margin: 0;
            caret-color: #4ade80;
            caret-shape: block;
            /* Some browsers support this */
        }

        /* Improved blinking block cursor simulation for browsers that don't support caret-shape */
        #console-input:focus {
            outline: none;
        }

        @keyframes cursor-blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        /* Text selection color */
        #console-input::selection {
            background: rgba(74, 222, 128, 0.4);
            color: #000;
        }

        .close-term {
            margin-left: auto;
            cursor: pointer;
            color: #666;
            transition: color 0.2s;
        }

        .close-term:hover {
            color: #ef4444;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .log-entry {
            margin-bottom: 2px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .log-error {
            color: var(--danger);
        }
    </style>
</head>

<body>
    <!-- Rest of HTML remains same, just styling updated via root and classes -->

    <!-- Navbar -->
    <div id="navbar">
        <div class="brand">
            <i class="material-icons-round" style="color: var(--primary)">hub</i>
            NetSim<span>.io</span>
        </div>

        <div class="toolbar">
            <button id="tool-select" class="tool-btn active" onclick="switchTool('select')" title="Select Tool">
                <i class="material-icons-round">near_me</i> Select
            </button>
            <button id="tool-link" class="tool-btn" onclick="switchTool('link')" title="Link Tool">
                <i class="material-icons-round">timeline</i> Link
            </button>
            <button id="tool-reset" class="tool-btn" onclick="resetSimulation()" title="Reset Simulation">
                <i class="material-icons-round">refresh</i> Reset
            </button>
            <button id="tool-pan" class="tool-btn" title="Pan Tool" onclick="switchTool('pan')">
                <i class="material-icons-round">pan_tool</i> Pan
            </button>
        </div>

        <div class="actions">
            <button class="btn btn-primary" onclick="alert('Simulation is running')">
                <i class="material-icons-round">play_arrow</i> Start Sim
            </button>
        </div>
    </div>

    <!-- Workspace -->
    <div id="workspace">

        <!-- Node Palette -->
        <div id="node-palette">
            <div class="palette-item" title="Add Host" onclick="addNodeToTopology('host')">
                <i class="material-icons-round">computer</i>
            </div>
            <div class="palette-item" title="Add Router" onclick="addNodeToTopology('router')">
                <i class="material-icons-round">router</i>
            </div>
            <div class="palette-item" title="Add Switch" onclick="addNodeToTopology('switch')">
                <i class="material-icons-round">hub</i>
            </div>
            <div class="palette-item" title="Add DNS Server" onclick="addNodeToTopology('dns_server')">
                <i class="material-icons-round">dns</i>
            </div>
        </div>

        <div class="resizer-v" id="left-resizer"></div>

        <!-- Graph Area -->
        <div id="network-graph"></div>

        <div class="resizer-v" id="sidebar-resizer"></div>

        <!-- Properties Panel (Right) -->
        <div id="properties-panel">
            <div id="panel-empty" class="empty-state">
                <i class="material-icons-round">settings_input_component</i>
                <div style="font-weight: 600; margin-bottom: 5px;">No Selection</div>
                <div style="font-size: 13px;">Select a node from the topology map to view and edit its properties.</div>
            </div>

            <div id="panel-content" style="display: none;">
                <div class="panel-header">
                    <div class="panel-title">
                        <i class="material-icons-round" style="color: var(--primary)">tune</i> Properties
                    </div>
                    <span class="node-badge" id="prop-type-badge">HOST</span>
                </div>

                <div class="panel-tabs">
                    <div class="panel-tab active" id="tab-props" onclick="switchTab('props')">Properties</div>
                    <div class="panel-tab" id="tab-inspect" onclick="switchTab('inspect')">Inspect</div>
                    <div class="panel-tab" id="tab-fault" onclick="switchTab('fault')">Corruption</div>
                    <div class="panel-tab" id="tab-monitor" onclick="switchTab('monitor')">Monitor</div>
                </div>

                <div class="panel-content" id="content-props">
                    <div class="input-group">
                        <div class="input-label">Node ID</div>
                        <div style="font-size: 12px; color: #666; font-family: 'JetBrains Mono';" id="prop-id">
                            node-12345</div>
                    </div>

                    <div class="input-group">
                        <div class="input-label">Hostname</div>
                        <input type="text" class="styled-input" id="prop-hostname" value="host-1">
                    </div>

                    <div class="input-group">
                        <div class="input-label">Default Gateway</div>
                        <input type="text" class="styled-input" id="prop-gateway" value="">
                    </div>

                    <div class="input-group">
                        <div class="input-label">Interfaces</div>
                        <div id="prop-interfaces" style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- populated by js -->
                        </div>
                    </div>

                    <button class="btn btn-primary btn-save-anim"
                        style="width: 100%; margin-top: 12px; height: 32px; font-size: 12px;"
                        onclick="saveNodeProperties()">
                        <i class="material-icons-round" style="font-size: 16px;">save</i> Save Changes
                    </button>
                </div>

                <div class="panel-content" id="content-inspect" style="display: none;">
                    <div class="inspection-header">
                        <h4>ARP Cache</h4>
                    </div>
                    <table class="inspection-table" id="arp-table">
                        <thead>
                            <tr>
                                <th>IP Address</th>
                                <th>MAC</th>
                                <th>Age</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>

                    <div class="inspection-header">
                        <h4>Routing Table</h4>
                    </div>
                    <table class="inspection-table" id="route-table">
                        <thead>
                            <tr>
                                <th>Target</th>
                                <th>Gateway</th>
                                <th>Iface</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>

                    <div class="inspection-header">
                        <h4>Active Sockets</h4>
                    </div>
                    <table class="inspection-table" id="socket-table">
                        <thead>
                            <tr>
                                <th>Proto</th>
                                <th>Local</th>
                                <th>Foreign</th>
                                <th>State</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>


                <div class="panel-content" id="content-fault" style="display: none;">
                    <div class="input-group">
                        <div class="input-label">Node Failures</div>
                        <div id="fault-node-failures" style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- Populated by JavaScript based on node type and current failures -->
                        </div>
                    </div>

                    <div class="input-group">
                        <div class="input-label">Interface Control</div>
                        <div id="fault-interfaces" style="display: flex; flex-direction: column; gap: 8px;">
                            <!-- populated by js -->
                        </div>
                    </div>
                </div>

                <div class="panel-content" id="content-monitor" style="display: none;">
                    <div class="inspection-header">
                        <h4>Hop-by-Hop Monitor</h4>
                    </div>
                    <div id="monitor-log"
                        style="font-family: 'JetBrains Mono'; font-size: 10px; line-height: 1.4; color: #888; overflow-y: auto; max-height: 500px;">
                        <!-- Events populated here -->
                    </div>
                </div>

                <div id="node-actions" style="padding: 24px; border-top: 1px solid var(--border); margin-top: auto;">
                    <button class="btn btn-primary" style="width: 100%; margin-bottom: 12px;" onclick="openTerminal()">
                        <i class="material-icons-round">terminal</i> Terminal
                    </button>
                    <button class="btn btn-danger" onclick="deleteSelectedNode()">
                        <i class="material-icons-round">delete</i> Delete Node
                    </button>
                </div>
            </div>
        </div>

        <div class="resizer-h" id="terminal-resizer"></div>

        <!-- Terminal Overlay -->
        <div id="terminal-panel">
            <div class="terminal-header">
                <span class="terminal-tab">>_ TTY: <span id="term-title-name">host-1</span></span>
                <i class="material-icons-round close-term" onclick="toggleTerminal()">close</i>
            </div>
            <div class="terminal-content" id="console-output"
                onclick="document.getElementById('console-input').focus()">
                <!-- Logs go here -->
                <div id="log-container"></div>
                <div class="input-line">
                    <span class="prompt" id="console-prompt">root@host-1:~#</span>
                    <input type="text" id="console-input" autocomplete="off" spellcheck="false">
                </div>
            </div>
        </div>

    </div>

    <script>
        const API_URL = "http://localhost:8000/api";
        const WS_URL = "ws://localhost:8000/ws/packets";

        // Initialize Vis.js DataSets
        const nodesDataSet = new vis.DataSet();
        const edgesDataSet = new vis.DataSet();
        let network = null;
        let selectedNodeId = null;
        let selectedNodeData = null;

        let socket = null;
        let activeProcesses = {}; // pid -> { last_index, is_finished }

        let currentTool = 'select';
        let linkSource = null;

        function switchTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`tool-${tool}`).classList.add('active');

            if (tool === 'link') {
                if (network) network.setOptions({ interaction: { dragNodes: false, dragView: true } });
                showToast("Link Mode: Click source node, then target node");
            } else if (tool === 'pan') {
                linkSource = null;
                if (network) network.setOptions({ interaction: { dragNodes: false, dragView: true } });
            } else {
                linkSource = null;
                if (network) network.setOptions({ interaction: { dragNodes: true, dragView: true } });
            }
        }

        function showToast(msg) {
            // Simple toast implementation or just console log for now
            console.log(msg);
        }

        async function resetSimulation() {
            alert("Reset function not yet implemented in new backend");
            // TODO: Implement reset endpoint in backend
            return;
            if (!confirm("Are you sure you want to reset the simulation? All custom nodes and links will be lost.")) return;
            try {
                await fetch(`${API_URL}/control/reset`, { method: 'POST' });
                fetchState();
            } catch (e) {
                alert("Failed to reset: " + e.message);
            }
        }

        // --- Icons Map ---
        const ICONS = {
            host: { code: '\ue31e', color: '#10b981' }, // Laptop
            router: { code: '\ue328', color: '#3b82f6' }, // Router
            switch: { code: '\ue32a', color: '#f59e0b' }, // Switch axis (?) or ie320
            dns_server: { code: '\ue1bd', color: '#8b5cf6' }, // DNS/Storage
            isp: { code: '\ue2bd', color: '#ef4444' } // Cloud
        };

        function initGraph() {
            const container = document.getElementById('network-graph');
            const data = { nodes: nodesDataSet, edges: edgesDataSet };
            const options = {
                nodes: {
                    shape: 'icon',
                    icon: {
                        face: 'Material Icons Round',
                        size: 35,
                        color: '#e2e8f0'
                    },
                    font: { size: 12, color: '#94a3b8', face: 'Inter', valign: 'bottom', multi: 'md' },
                    shadow: { enabled: true, color: 'rgba(0,0,0,0.5)', size: 10, x: 5, y: 5 },
                },
                edges: {
                    width: 2,
                    color: { color: '#334155', highlight: '#94a3b8' },
                    dashes: true, // As per screenshot
                    smooth: { type: 'continuous', roundness: 0 },
                    font: { color: '#64748b', strokeWidth: 0, size: 10, align: 'top' }
                },
                physics: {
                    solver: 'barnesHut',
                    barnesHut: {
                        gravitationalConstant: -4000,
                        centralGravity: 0.3,
                        springLength: 120,
                        springConstant: 0.01,
                        damping: 0.3,
                        avoidOverlap: 0.2
                    },
                    stabilization: {
                        enabled: true,
                        iterations: 1000,
                        updateInterval: 50
                    }
                },
                interaction: { hover: true, tooltipDelay: 200 }
            };
            network = new vis.Network(container, data, options);

            network.on("click", async function (params) {
                if (params.nodes.length > 0) {
                    const nodeId = params.nodes[0];
                    if (currentTool === 'link') {
                        if (!linkSource) {
                            linkSource = nodeId;
                            showToast(`Source selected: ${nodeId}. Now click target node.`);
                        } else if (linkSource !== nodeId) {
                            const targetId = nodeId;
                            showToast(`Linking ${linkSource} to ${targetId}...`);
                            await createLink(linkSource, targetId);
                            linkSource = null;
                        }
                    } else {
                        selectNode(nodeId);
                    }
                } else if (params.edges.length > 0) {
                    selectLink(params.edges[0]);
                } else {
                    clearSelection();
                }
            });
        }

        // --- State Management ---

        async function fetchState() {
            try {
                // Fetch devices and links separately from new API
                const [devicesResponse, linksResponse] = await Promise.all([
                    fetch(`${API_URL}/devices`),
                    fetch(`${API_URL}/links`)
                ]);
                const devicesData = await devicesResponse.json();
                const linksData = await linksResponse.json();

                // Transform to old format for compatibility
                const data = {
                    nodes: devicesData.devices.map(d => ({
                        name: d.name,
                        type: d.type,
                        interfaces: [] // Will be populated from topology if needed
                    })),
                    links: linksData.links.map(l => ({
                        id: l.id,
                        source: l.device_a,
                        target: l.device_b,
                        latency_ms: l.latency_ms
                    }))
                };

                // Nodes Sync
                const currentNodes = nodesDataSet.getIds();
                const newNodes = new Set(data.nodes.map(n => n.name));
                const nodesToRemove = currentNodes.filter(id => !newNodes.has(id));
                nodesDataSet.remove(nodesToRemove);

                data.nodes.forEach(n => {
                    const iconDef = ICONS[n.type] || ICONS.host;
                    const isSelected = selectedNodeId === n.name;

                    // Get first IP address for label
                    let ipAddress = '';
                    if (n.interfaces && n.interfaces.length > 0) {
                        for (const iface of n.interfaces) {
                            if (iface.ips && iface.ips.length > 0) {
                                ipAddress = iface.ips[0].split('/')[0];
                                break;
                            }
                        }
                    }

                    // Create label with IP address below node name
                    const label = ipAddress ? `${n.name}\n${ipAddress}` : n.name;

                    const nodeObj = {
                        id: n.name,
                        label: label,
                        icon: {
                            code: iconDef.code,
                            color: isSelected ? '#10b981' : iconDef.color,
                            size: isSelected ? 45 : 35
                        },
                        font: {
                            size: isSelected ? 14 : 12,
                            color: isSelected ? '#10b981' : '#94a3b8',
                            face: 'Inter',
                            valignn: 'bottom',
                            multi: false,
                            bold: isSelected
                        },
                        borderWidth: isSelected ? 3 : 0,
                        borderWidthSelected: 3,
                        shapeProperties: {
                            borderDashes: false
                        }
                    };

                    if (nodesDataSet.get(n.name)) {
                        nodesDataSet.update(nodeObj);
                    } else {
                        nodesDataSet.add(nodeObj);
                    }
                });

                // Edges Sync
                const currentEdges = edgesDataSet.getIds();
                const newEdges = new Set(data.links.map(l => l.id));
                const edgesToRemove = currentEdges.filter(id => !newEdges.has(id));
                edgesDataSet.remove(edgesToRemove);

                data.links.forEach(l => {
                    if (!edgesDataSet.get(l.id)) {
                        edgesDataSet.add({
                            id: l.id,
                            from: l.source_node,
                            to: l.target_node
                        });
                    }
                });

            } catch (e) { console.error(e); }
        }

        async function selectNode(name) {
            selectedNodeId = name;
            const response = await fetch(`${API_URL}/state`);
            const data = await response.json();
            const nodeData = data.nodes.find(n => n.name === name);
            if (nodeData) {
                selectedNodeData = nodeData;
                updatePropertiesPanel(nodeData);
                // Trigger visual update for selection highlight
                fetchState();
            }
        }

        async function selectLink(id) {
            selectedNodeId = null; // Clear node selection
            const response = await fetch(`${API_URL}/state`);
            const state = await response.json();
            const link = state.links.find(l => l.id === id);
            if (link) {
                updateLinkProperties(link);
            }
        }

        function updateLinkProperties(link) {
            console.log('Updating link properties:', link);

            // Show panel and hide empty state
            document.getElementById('panel-empty').style.display = 'none';
            document.getElementById('panel-content').style.display = 'flex';
            document.getElementById('panel-content').style.flexDirection = 'column';
            document.getElementById('panel-content').style.height = '100%';

            // Switch to properties tab
            switchTab('props');

            // Update header
            document.getElementById('prop-type-badge').innerText = 'LINK';
            document.getElementById('prop-id').innerText = link.id;

            // Hide node-specific fields
            document.getElementById('prop-hostname').parentElement.style.display = 'none';
            document.getElementById('prop-gateway').parentElement.style.display = 'none';

            // Hide node-specific actions (Terminal and Delete Node buttons)
            document.getElementById('node-actions').style.display = 'none';

            // Show link properties in the interfaces container
            const container = document.getElementById('prop-interfaces');
            container.innerHTML = `
                <div class="input-group">
                    <div class="input-label">Source Node</div>
                    <input type="text" class="styled-input" value="${link.source_node}" readonly>
                </div>
                <div class="input-group">
                    <div class="input-label">Target Node</div>
                    <input type="text" class="styled-input" value="${link.target_node}" readonly>
                </div>
                <div class="input-group">
                    <div class="input-label">Latency (ms)</div>
                    <input type="number" class="styled-input" value="${link.latency}" onchange="updateLinkAttr('${link.id}', 'latency', this.value)">
                </div>
                <div class="input-group">
                    <div class="input-label">Packet Loss (%)</div>
                    <input type="number" step="0.01" class="styled-input" value="${link.packet_loss || 0}" onchange="updateLinkAttr('${link.id}', 'packet_loss', this.value)">
                </div>
                
                <button class="btn btn-danger" style="width: 100%; margin-top: 20px;" onclick="deleteSelectedLink('${link.id}')">
                    <i class="material-icons-round">delete</i> Delete Link
                </button>
            `;

            // Clear inspection tables
            document.querySelector('#arp-table tbody').innerHTML = '';
            document.querySelector('#route-table tbody').innerHTML = '';
            document.querySelector('#socket-table tbody').innerHTML = '';

            // Clear fault interfaces
            document.getElementById('fault-interfaces').innerHTML = '<div style="color: var(--text-mute); font-size: 12px; padding: 10px;">Link-specific controls not available</div>';
        }

        async function updateLinkAttr(id, attr, value) {
            await fetch(`${API_URL}/failure/enable`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: `${attr}_${id}`, type: attr, target: id, value: value })
            });
            fetchState();
        }

        function clearSelection() {
            selectedNodeId = null;
            document.getElementById('panel-empty').style.display = 'flex';
            document.getElementById('panel-content').style.display = 'none';
            document.getElementById('terminal-panel').classList.remove('open');
            fetchState();
        }

        function updatePropertiesPanel(node) {
            console.log('Updating properties panel for node:', node);

            document.getElementById('panel-empty').style.display = 'none';
            document.getElementById('panel-content').style.display = 'flex';
            document.getElementById('panel-content').style.flexDirection = 'column';
            document.getElementById('panel-content').style.height = '100%';

            // ALWAYS show node-specific actions (Terminal and Delete Node buttons)
            // These buttons should work for ALL node types: hosts, routers, switches, DNS servers
            document.getElementById('node-actions').style.display = 'block';

            // Show hostname and gateway fields (they might be hidden from link selection)
            document.getElementById('prop-hostname').parentElement.style.display = 'block';

            // Gateway field only makes sense for hosts and DNS servers (not routers/switches)
            const showGateway = node.type === 'host' || node.type === 'dns_server';
            document.getElementById('prop-gateway').parentElement.style.display = showGateway ? 'block' : 'none';

            // Update basic info
            document.getElementById('prop-type-badge').innerText = node.type.toUpperCase();
            document.getElementById('prop-id').innerText = `node-${node.id}`;
            document.getElementById('prop-hostname').value = node.name;

            // Find default gateway from routing table (if applicable)
            const defaultRoute = node.routing_table.find(r => r.dst === '0.0.0.0/0');
            document.getElementById('prop-gateway').value = defaultRoute ? defaultRoute.gw : '';

            // Interfaces
            const container = document.getElementById('prop-interfaces');
            container.innerHTML = '';

            const faultContainer = document.getElementById('fault-interfaces');
            faultContainer.innerHTML = '';

            if (node.interfaces && node.interfaces.length > 0) {
                node.interfaces.forEach(iface => {
                    // Prop panel - show interface with IP
                    const div = document.createElement('input');
                    div.className = 'styled-input';
                    div.style.marginBottom = '5px';
                    const ipDisplay = iface.ips && iface.ips.length > 0 ? iface.ips[0] : 'No IP';
                    div.value = `${iface.name}: ${ipDisplay}`;
                    div.readOnly = true;
                    container.appendChild(div);

                    // Fault panel - interface control (ALL node types can have interfaces up/down)
                    const row = document.createElement('div');
                    row.className = 'interface-control';
                    row.style.display = 'flex';
                    row.style.gap = '10px';
                    row.style.alignItems = 'center';
                    const state = iface.state.toLowerCase();

                    const label = document.createElement('div');
                    label.style.flex = '1';
                    label.style.fontSize = '13px';
                    label.style.fontWeight = '500';
                    label.textContent = iface.name;
                    row.appendChild(label);

                    const button = document.createElement('button');
                    button.id = `btn-iface-${iface.name}`;  // Add unique ID
                    button.className = `btn ${state === 'up' ? 'btn-success' : 'btn-danger'}`;
                    button.style.padding = '6px 12px';
                    button.style.fontSize = '11px';
                    button.style.fontWeight = '600';
                    button.style.minWidth = '80px';
                    button.style.transition = 'all 0.2s ease';
                    button.onclick = () => toggleInterface(iface.name, state, button);  // Pass button element
                    button.innerHTML = `
                        <i class="material-icons-round" style="font-size: 14px; vertical-align: middle;">${state === 'up' ? 'arrow_upward' : 'arrow_downward'}</i>
                        ${state.toUpperCase()}
                    `;
                    row.appendChild(button);

                    faultContainer.appendChild(row);
                });
            } else {
                container.innerHTML = '<div style="color: var(--text-mute); font-size: 12px;">No interfaces</div>';
            }

            // Update inspection tables (ALL node types have ARP cache, routing table, sockets)
            updateInspectionTables(node);

            // Update failure controls (Block ICMP, Silent Router, etc.)
            updateFailureControls(node);
        }

        function switchTab(tab) {
            ['props', 'inspect', 'fault', 'monitor'].forEach(t => {
                document.getElementById(`tab-${t}`).classList.toggle('active', t === tab);
                document.getElementById(`content-${t}`).style.display = t === tab ? 'block' : 'none';
            });
        }

        function updateInspectionTables(node) {
            // ARP Cache
            const arpBody = document.querySelector('#arp-table tbody');
            arpBody.innerHTML = '';
            const arpEntries = Object.entries(node.arp_cache || {});
            if (arpEntries.length > 0) {
                for (const [ip, entry] of arpEntries) {
                    arpBody.innerHTML += `<tr><td>${ip}</td><td>${entry.mac}</td><td>${Math.round(entry.age)}s</td></tr>`;
                }
            } else {
                arpBody.innerHTML = '<tr><td colspan="3" style="text-align: center; color: var(--text-mute); font-style: italic; padding: 20px;">No ARP entries yet. Send a ping to populate the ARP cache.</td></tr>';
            }

            // Routing Table
            const routeBody = document.querySelector('#route-table tbody');
            routeBody.innerHTML = '';
            const routes = node.routing_table || [];
            if (routes.length > 0) {
                routes.forEach(r => {
                    routeBody.innerHTML += `<tr><td>${r.dst}</td><td>${r.gw || '*'}</td><td>${r.dev}</td></tr>`;
                });
            } else {
                routeBody.innerHTML = '<tr><td colspan="3" style="text-align: center; color: var(--text-mute); font-style: italic; padding: 20px;">No routes configured</td></tr>';
            }

            // Sockets
            const socketBody = document.querySelector('#socket-table tbody');
            socketBody.innerHTML = '';
            const sockets = node.sockets || [];
            if (sockets.length > 0) {
                sockets.forEach(s => {
                    socketBody.innerHTML += `<tr><td>${s.protocol}</td><td>:${s.local_port}</td><td>${s.remote_ip || '*'}:${s.remote_port || '*'}</td><td>${s.state}</td></tr>`;
                });
            } else {
                socketBody.innerHTML = '<tr><td colspan="4" style="text-align: center; color: var(--text-mute); font-style: italic; padding: 20px;">No active sockets</td></tr>';
            }
        }

        async function updateFailureControls(node) {
            const container = document.getElementById('fault-node-failures');
            if (!container) return;

            container.innerHTML = '';

            // Get current failures
            let activeFailures = {};
            try {
                const res = await fetch(`${API_URL}/failures`);
                const failures = await res.json();
                activeFailures = failures || {};
            } catch (e) {
                console.error('Failed to fetch failures:', e);
            }

            // Check which failures are active for this node
            const icmpBlocked = Object.keys(activeFailures).some(id =>
                activeFailures[id].type === 'icmp_block' && activeFailures[id].node === node.name
            );
            const silentRouter = Object.keys(activeFailures).some(id =>
                activeFailures[id].type === 'silent_router' && activeFailures[id].node === node.name
            );

            // Block ICMP button (available for ALL node types)
            const icmpBtn = document.createElement('button');
            icmpBtn.id = 'btn-icmp-block';  // Add unique ID
            icmpBtn.className = `btn ${icmpBlocked ? 'btn-danger' : 'btn-outline'}`;
            icmpBtn.style.cssText = 'width: 100%; margin-bottom: 8px; justify-content: flex-start; transition: all 0.2s ease;';
            icmpBtn.onclick = () => toggleFailure('icmp_block', icmpBlocked, icmpBtn);
            icmpBtn.innerHTML = `
                <i class="material-icons-round">block</i> 
                Block ICMP ${icmpBlocked ? '<span style="color: #fbbf24; font-weight: 700;">(ACTIVE)</span>' : ''}
            `;
            container.appendChild(icmpBtn);

            // Silent Router button (available for routers, but can work on any node)
            const silentBtn = document.createElement('button');
            silentBtn.id = 'btn-silent-mode';  // Add unique ID
            silentBtn.className = `btn ${silentRouter ? 'btn-danger' : 'btn-outline'}`;
            silentBtn.style.cssText = 'width: 100%; margin-bottom: 8px; justify-content: flex-start; transition: all 0.2s ease;';
            silentBtn.onclick = () => toggleFailure('silent_router', silentRouter, silentBtn);
            const label = node.type === 'router' ? 'Silent Router' : 'Silent Mode';
            silentBtn.innerHTML = `
                <i class="material-icons-round">volume_off</i> 
                ${label} ${silentRouter ? '<span style="color: #fbbf24; font-weight: 700;">(ACTIVE)</span>' : ''}
            `;
            container.appendChild(silentBtn);

            // Add note for non-router nodes
            if (node.type !== 'router') {
                const note = document.createElement('div');
                note.style.cssText = 'font-size: 11px; color: var(--text-mute); margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px;';
                note.innerHTML = `
                    <i class="material-icons-round" style="font-size: 14px; vertical-align: middle;">info</i>
                    Silent mode prevents this node from sending ICMP error messages.
                `;
                container.appendChild(note);
            }
        }

        async function toggleFailure(type, isCurrentlyActive, buttonElement) {
            if (!selectedNodeId) return;

            console.log(`Toggle ${type}: currently ${isCurrentlyActive ? 'active' : 'inactive'}`);

            // Immediately update button appearance for instant feedback
            const newState = !isCurrentlyActive;

            if (buttonElement) {
                // Disable button to prevent double-clicks
                buttonElement.disabled = true;
                buttonElement.style.cursor = 'wait';

                // Update button appearance immediately
                if (newState) {
                    // Enabling - turn red
                    buttonElement.className = 'btn btn-danger';
                    buttonElement.style.transform = 'scale(0.95)';
                    setTimeout(() => buttonElement.style.transform = 'scale(1)', 100);

                    // Update text
                    const icon = buttonElement.querySelector('i');
                    const text = type === 'icmp_block' ? 'Block ICMP' :
                        (selectedNodeData.type === 'router' ? 'Silent Router' : 'Silent Mode');
                    buttonElement.innerHTML = `
                        ${icon.outerHTML}
                        ${text} <span style="color: #fbbf24; font-weight: 700;">(ACTIVE)</span>
                    `;
                } else {
                    // Disabling - turn gray
                    buttonElement.className = 'btn btn-outline';
                    buttonElement.style.transform = 'scale(0.95)';
                    setTimeout(() => buttonElement.style.transform = 'scale(1)', 100);

                    // Update text
                    const icon = buttonElement.querySelector('i');
                    const text = type === 'icmp_block' ? 'Block ICMP' :
                        (selectedNodeData.type === 'router' ? 'Silent Router' : 'Silent Mode');
                    buttonElement.innerHTML = `
                        ${icon.outerHTML}
                        ${text}
                    `;
                }
            }

            try {
                if (isCurrentlyActive) {
                    // Disable the failure - find and delete it
                    console.log('Disabling failure...');
                    const res = await fetch(`${API_URL}/failures`);
                    const failures = await res.json();
                    const failureId = Object.keys(failures).find(id =>
                        failures[id].type === type && failures[id].node === selectedNodeId
                    );

                    if (failureId) {
                        const deleteRes = await fetch(`${API_URL}/failure/${failureId}`, { method: 'DELETE' });
                        const result = await deleteRes.json();
                        console.log('Disable result:', result);
                        showToast(result.message || `${type.replace('_', ' ')} disabled`, 'success');
                    }
                } else {
                    // Enable the failure
                    console.log('Enabling failure...');
                    const enableRes = await fetch(`${API_URL}/failure/enable`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            id: `${type}_${selectedNodeId}`,
                            type: type,
                            target: selectedNodeId
                        })
                    });

                    const result = await enableRes.json();
                    console.log('Enable result:', result);

                    if (enableRes.ok) {
                        showToast(result.message || `${type.replace('_', ' ')} enabled`, 'success');
                    } else {
                        // Revert button state on error
                        if (buttonElement) {
                            buttonElement.className = isCurrentlyActive ? 'btn btn-danger' : 'btn btn-outline';
                            const icon = buttonElement.querySelector('i');
                            const text = type === 'icmp_block' ? 'Block ICMP' :
                                (selectedNodeData.type === 'router' ? 'Silent Router' : 'Silent Mode');
                            if (isCurrentlyActive) {
                                buttonElement.innerHTML = `${icon.outerHTML} ${text} <span style="color: #fbbf24; font-weight: 700;">(ACTIVE)</span>`;
                            } else {
                                buttonElement.innerHTML = `${icon.outerHTML} ${text}`;
                            }
                        }
                        showToast(result.detail || 'Failed to toggle failure', 'error');
                    }
                }
            } catch (e) {
                console.error('Failed to toggle failure:', e);
                // Revert button state on error
                if (buttonElement) {
                    buttonElement.className = isCurrentlyActive ? 'btn btn-danger' : 'btn btn-outline';
                    const icon = buttonElement.querySelector('i');
                    const text = type === 'icmp_block' ? 'Block ICMP' :
                        (selectedNodeData.type === 'router' ? 'Silent Router' : 'Silent Mode');
                    if (isCurrentlyActive) {
                        buttonElement.innerHTML = `${icon.outerHTML} ${text} <span style="color: #fbbf24; font-weight: 700;">(ACTIVE)</span>`;
                    } else {
                        buttonElement.innerHTML = `${icon.outerHTML} ${text}`;
                    }
                }
                showToast('Network error', 'error');
            } finally {
                // Re-enable button
                if (buttonElement) {
                    buttonElement.disabled = false;
                    buttonElement.style.cursor = 'pointer';
                }
            }

            // Don't refresh automatically - trust the button state we just set
            // The button is already showing the correct state
            // Only the error handlers above will revert if something went wrong
        }

        async function toggleInterface(iface, currentState, buttonElement) {
            if (!selectedNodeId) return;

            console.log(`Toggle interface ${iface}: currently ${currentState}`);

            // Use passed button element instead of searching
            const targetButton = buttonElement;

            const newState = currentState === 'up' ? 'down' : 'up';

            // Immediately update button appearance
            if (targetButton) {
                targetButton.disabled = true;
                targetButton.style.cursor = 'wait';
                targetButton.style.transform = 'scale(0.95)';
                setTimeout(() => targetButton.style.transform = 'scale(1)', 100);

                if (newState === 'down') {
                    targetButton.className = 'btn btn-danger';
                    targetButton.innerHTML = `<i class="material-icons-round" style="font-size: 14px; vertical-align: middle;">arrow_downward</i> DOWN`;
                } else {
                    targetButton.className = 'btn btn-success';
                    targetButton.innerHTML = `<i class="material-icons-round" style="font-size: 14px; vertical-align: middle;">arrow_upward</i> UP`;
                }
            }

            try {
                if (currentState === 'up') {
                    // Shutdown interface
                    console.log(`Shutting down interface ${iface}...`);
                    const res = await fetch(`${API_URL}/failure/enable`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            id: `shutdown_${selectedNodeId}_${iface}`,
                            type: 'interface_shutdown',
                            target: `${selectedNodeId}:${iface}`
                        })
                    });

                    const result = await res.json();
                    console.log('Shutdown result:', result);
                    if (res.ok) {
                        showToast(result.message || `Interface ${iface} shut down`, 'success');
                    } else {
                        // Revert on error
                        if (targetButton) {
                            targetButton.className = 'btn btn-success';
                            targetButton.innerHTML = `<i class="material-icons-round">arrow_upward</i> UP`;
                        }
                        showToast(result.detail || 'Failed to shutdown interface', 'error');
                    }
                } else {
                    // Restore interface
                    console.log(`Restoring interface ${iface}...`);
                    const res = await fetch(`${API_URL}/failure/enable`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            id: `restore_${selectedNodeId}_${iface}`,
                            type: 'interface_restore',
                            target: `${selectedNodeId}:${iface}`
                        })
                    });

                    const result = await res.json();
                    console.log('Restore result:', result);
                    if (res.ok) {
                        showToast(result.message || `Interface ${iface} restored`, 'success');
                    } else {
                        // Revert on error
                        if (targetButton) {
                            targetButton.className = 'btn btn-danger';
                            targetButton.innerHTML = `<i class="material-icons-round">arrow_downward</i> DOWN`;
                        }
                        showToast(result.detail || 'Failed to restore interface', 'error');
                    }
                }
            } catch (e) {
                console.error('Failed to toggle interface:', e);
                // Revert button state on error
                if (targetButton) {
                    if (currentState === 'up') {
                        targetButton.className = 'btn btn-success';
                        targetButton.innerHTML = `<i class="material-icons-round">arrow_upward</i> UP`;
                    } else {
                        targetButton.className = 'btn btn-danger';
                        targetButton.innerHTML = `<i class="material-icons-round">arrow_downward</i> DOWN`;
                    }
                }
                showToast('Network error', 'error');
            } finally {
                // Re-enable button
                if (targetButton) {
                    targetButton.disabled = false;
                    targetButton.style.cursor = 'pointer';
                }
            }

            // Don't refresh automatically - trust the button state we just set
            // The button is already showing the correct state
            // Only the error handlers above will revert if something went wrong
        }

        // --- Terminal ---

        function toggleTerminal() {
            document.getElementById('terminal-panel').classList.toggle('open');
        }

        function openTerminal() {
            if (!selectedNodeId) return;
            const panel = document.getElementById('terminal-panel');
            panel.classList.add('open');

            // Reset terminal content with boot banner if strictly switching?
            // For now just clear and show header
            const log = document.getElementById('log-container');
            log.innerHTML = '';

            // Banner
            const banner = document.createElement('div');
            banner.className = 'log-boot';
            banner.innerText = `Linux ${selectedNodeId} 5.10.0-28-amd64 #1 SMP Simulator (2025) x86_64\nType "help" for a list of supported commands.\n`;
            log.appendChild(banner);

            document.getElementById('term-title-name').innerText = `${selectedNodeId} (${getHostIp()})`;
            document.getElementById('console-prompt').innerText = `root@${selectedNodeId}:~#`;
            document.getElementById('console-input').focus();
        }

        function getHostIp() {
            if (!selectedNodeData || !selectedNodeData.interfaces) return 'no IP';

            // Find first interface with an IP
            for (const iface of selectedNodeData.interfaces) {
                if (iface.ips && iface.ips.length > 0) {
                    return iface.ips[0].split('/')[0];
                }
            }

            return 'no IP';
        }

        // Command history
        let commandHistory = [];
        let historyIndex = -1;

        document.getElementById('console-input').addEventListener('keydown', function (e) {
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (commandHistory.length > 0) {
                    if (historyIndex < commandHistory.length - 1) {
                        historyIndex++;
                        this.value = commandHistory[commandHistory.length - 1 - historyIndex];
                    }
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    this.value = commandHistory[commandHistory.length - 1 - historyIndex];
                } else if (historyIndex === 0) {
                    historyIndex = -1;
                    this.value = '';
                }
            }
        });

        document.getElementById('console-input').addEventListener('keypress', async function (e) {
            if (e.key === 'Enter') {
                const cmd = this.value.trim();
                this.value = '';

                if (!cmd) return;

                // Add to history
                if (cmd !== 'clear') {
                    commandHistory.push(cmd);
                    if (commandHistory.length > 100) commandHistory.shift(); // Limit history
                }
                historyIndex = -1;

                const log = document.getElementById('log-container');
                const entry = document.createElement('div');
                entry.innerHTML = `<span class="prompt">root@${selectedNodeId}:~#</span> ${cmd}`;
                log.appendChild(entry);

                if (cmd === 'clear') {
                    log.innerHTML = '';
                    return;
                }

                try {
                    // Update UI to show "running" state?
                    const response = await fetch(`${API_URL}/command`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ node_name: selectedNodeId, command: cmd })
                    });
                    const result = await response.json();

                    if (result.stdout) {
                        const out = document.createElement('div');
                        out.innerHTML = ansiToHtml(result.stdout);
                        out.className = 'log-entry';
                        log.appendChild(out);
                    }
                    if (result.stderr) {
                        const err = document.createElement('div');
                        err.innerHTML = ansiToHtml(result.stderr);
                        err.className = 'log-entry log-error';
                        log.appendChild(err);
                    }
                } catch (e) {
                    const errDiv = document.createElement('div');
                    errDiv.innerText = "Error: " + e.message;
                    errDiv.className = 'log-error';
                    log.appendChild(errDiv);
                }

                // Scroll to bottom with smooth animation
                const container = document.getElementById('console-output');
                setTimeout(() => {
                    container.scrollTop = container.scrollHeight;
                }, 50);
            }
        });

        function initWebSocket() {
            socket = new WebSocket(WS_URL);
            socket.onmessage = function (event) {
                const data = JSON.parse(event.data);

                // Update terminal if we have an active process matching selected node
                if (data.processes && selectedNodeId) {
                    data.processes.forEach(proc => {
                        if (proc.node === selectedNodeId) {
                            const pid = proc.pid;
                            if (!activeProcesses[pid]) {
                                activeProcesses[pid] = { last_index: 0 };
                            }
                            const lastIdx = activeProcesses[pid].last_index;
                            if (proc.output.length > lastIdx) {
                                const newLines = proc.output.slice(lastIdx);
                                const log = document.getElementById('log-container');
                                newLines.forEach(line => {
                                    const out = document.createElement('div');
                                    out.innerText = line;
                                    out.className = 'log-entry';
                                    log.appendChild(out);
                                });
                                activeProcesses[pid].last_index = proc.output.length;
                                document.getElementById('console-output').scrollTop = document.getElementById('console-output').scrollHeight;
                            }
                        }
                    });
                }

                // Global Event Log (Hop-by-hop)
                if (data.history) {
                    const monitor = document.getElementById('monitor-log');
                    if (monitor) {
                        monitor.innerHTML = '';
                        data.history.forEach(h => {
                            const row = document.createElement('div');
                            row.style.marginBottom = '8px';
                            row.style.borderLeft = `2px solid ${h.event === 'dropped' ? '#ef4444' : '#22c55e'}`;
                            row.style.paddingLeft = '10px';
                            row.innerHTML = `
                                <div style="color:#eee; font-size:11px;"><b>[${h.event.toUpperCase()}]</b> ${h.packet_type}</div>
                                <div style="color:#94a3b8; font-size:10px;">${h.src_node || '?'} &rarr; ${h.dst_node || '?'}</div>
                                <div style="font-size:9px; color:#64748b">${h.details || h.reason || ''}</div>
                            `;
                            monitor.appendChild(row);
                        });
                    }
                }

                // Update packet animations
                if (data.packets) {
                    updatePacketVisuals(data.packets);
                }
            };
            socket.onclose = () => setTimeout(initWebSocket, 2000);
        }

        async function saveNodeProperties() {
            if (!selectedNodeId) return;

            const hostname = document.getElementById('prop-hostname').value;
            const gateway = document.getElementById('prop-gateway').value;

            try {
                const response = await fetch(`${API_URL}/topology/node/${selectedNodeId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        hostname: hostname,
                        gateway: gateway === '' ? null : gateway
                    })
                });

                const result = await response.json();
                if (response.ok) {
                    showToast("Node properties updated");
                    // If hostname changed, update our selection reference
                    if (hostname !== selectedNodeId) {
                        selectedNodeId = hostname;
                    }
                    await fetchState();
                    // Re-select to update variables
                    selectNode(selectedNodeId);
                } else {
                    showToast(`Error: ${result.detail || 'Update failed'}`, 'danger');
                }
            } catch (e) {
                console.error(e);
                showToast("Failed to connect to server", 'danger');
            }
        }

        // --- Packet Animation ---
        let activePacketVisuals = {}; // packet_id -> { src, dst, progress }

        function renderPacketAnimations() {
            if (!network) return;
            const canvas = network.canvas.frame.canvas;
            const ctx = canvas.getContext('2d');

            // Draw packets on edges
            for (const [pid, pkt] of Object.entries(activePacketVisuals)) {
                const srcPos = network.getPositions([pkt.src])[pkt.src];
                const dstPos = network.getPositions([pkt.dst])[pkt.dst];

                if (!srcPos || !dstPos) continue;

                const x = srcPos.x + (dstPos.x - srcPos.x) * pkt.progress;
                const y = srcPos.y + (dstPos.y - srcPos.y) * pkt.progress;

                // Convert to canvas coordinates
                const canvasPos = network.canvasToDOM({ x, y });

                ctx.beginPath();
                ctx.arc(canvasPos.x, canvasPos.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = pkt.type === 'ICMP' ? '#22c55e' : pkt.type === 'TCP' ? '#3b82f6' : '#f59e0b';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // --- Resizer Logic Updated ---
        let isResizingSidebar = false;
        let isResizingTerminal = false;
        let isResizingLeft = false;

        let startX = 0;
        let startY = 0;
        let startWidth = 0;
        let startHeight = 0;
        let startLeftWidth = 0;

        document.getElementById('sidebar-resizer').addEventListener('mousedown', (e) => {
            isResizingSidebar = true;
            startX = e.clientX;
            startWidth = document.getElementById('properties-panel').offsetWidth;
            e.preventDefault();
        });

        document.getElementById('left-resizer').addEventListener('mousedown', (e) => {
            isResizingLeft = true;
            startX = e.clientX;
            startLeftWidth = document.getElementById('node-palette').offsetWidth;
            e.preventDefault();
        });

        document.getElementById('terminal-resizer').addEventListener('mousedown', (e) => {
            isResizingTerminal = true;
            startY = e.clientY;
            startHeight = document.getElementById('terminal-panel').offsetHeight;
            e.preventDefault();
        });

        document.addEventListener('mousemove', (e) => {
            if (isResizingSidebar) {
                const delta = startX - e.clientX;
                const newWidth = Math.max(280, Math.min(600, startWidth + delta));
                document.getElementById('properties-panel').style.width = newWidth + 'px';
            }
            if (isResizingLeft) {
                const delta = e.clientX - startX;
                const newWidth = Math.max(64, Math.min(300, startLeftWidth + delta));
                document.getElementById('node-palette').style.width = newWidth + 'px';
            }
            if (isResizingTerminal) {
                // Since terminal is absolute bottom, dragging up increases height
                const delta = startY - e.clientY;
                const newHeight = Math.max(200, Math.min(800, startHeight + delta));
                document.getElementById('terminal-panel').style.height = newHeight + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            isResizingSidebar = false;
            isResizingTerminal = false;
            isResizingLeft = false;
        });

        // --- Node Palette ---
        async function addNodeToTopology(type) {
            const name = prompt(`Enter name for new ${type}:`);
            if (!name) return;

            try {
                const response = await fetch(`${API_URL}/devices`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, type })
                });
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail);
                }
                fetchState();
            } catch (e) {
                alert('Failed to add node: ' + e.message);
            }
        }

        async function createLink(source, target) {
            try {
                const response = await fetch(`${API_URL}/links`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_a: source, device_b: target, latency_ms: 10 })
                });
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail);
                }
                fetchState();
                showToast("Link created successfully");
            } catch (e) {
                alert('Failed to create link: ' + e.message);
            }
        }

        async function deleteSelectedNode() {
            if (!selectedNodeId) return;
            if (!confirm(`Delete node ${selectedNodeId}?`)) return;

            try {
                await fetch(`${API_URL}/devices/${selectedNodeId}`, { method: 'DELETE' });
                clearSelection();
                fetchState();
            } catch (e) {
                alert('Failed to delete node: ' + e.message);
            }
        }

        async function deleteSelectedLink(linkId) {
            if (!confirm(`Delete link?`)) return;
            try {
                await fetch(`${API_URL}/links/${linkId}`, { method: 'DELETE' });
                clearSelection();
                fetchState();
            } catch (e) {
                alert('Failed to delete link: ' + e.message);
            }
        }

        // Init
        initGraph();
        fetchState();
        initWebSocket();
        setInterval(fetchState, 2000);

        // Animation loop
        setInterval(() => {
            renderPacketAnimations();
        }, 50);

        // Update packet visuals from WebSocket
        function updatePacketVisuals(packets) {
            activePacketVisuals = {};
            packets.forEach(p => {
                activePacketVisuals[p.id] = {
                    src: p.src,
                    dst: p.dst,
                    progress: p.progress,
                    type: p.type
                };
            });
        }

        // --- ANSI Helper ---
        function ansiToHtml(text) {
            if (!text) return "";

            const colors = {
                // Normal colors
                '30': '#1e293b', // black
                '31': '#ef4444', // red
                '32': '#10b981', // green
                '33': '#f59e0b', // yellow
                '34': '#3b82f6', // blue
                '35': '#a855f7', // magenta
                '36': '#06b6d4', // cyan
                '37': '#e2e8f0', // white
                // Bright colors
                '90': '#475569', // bright black (gray)
                '91': '#f87171', // bright red
                '92': '#34d399', // bright green
                '93': '#fbbf24', // bright yellow
                '94': '#60a5fa', // bright blue
                '95': '#c084fc', // bright magenta
                '96': '#22d3ee', // bright cyan
                '97': '#f1f5f9'  // bright white
            };

            // Escape HTML
            let html = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            // Handle ANSI escape sequences
            html = html.replace(/\\x1b\[([0-9;]+)m/g, (match, code) => {
                if (code === '0') return '</span>';

                const parts = code.split(';');
                let styles = [];

                for (let p of parts) {
                    if (p === '1') {
                        styles.push('font-weight:bold');
                    } else if (p === '4') {
                        styles.push('text-decoration:underline');
                    } else if (colors[p]) {
                        styles.push('color:' + colors[p]);
                    }
                }

                return styles.length > 0 ? `<span style="${styles.join(';')}">` : '';
            });

            // Handle \\033 format (octal escape)
            html = html.replace(/\\033\[([0-9;]+)m/g, (match, code) => {
                if (code === '0') return '</span>';

                const parts = code.split(';');
                let styles = [];

                for (let p of parts) {
                    if (p === '1') {
                        styles.push('font-weight:bold');
                    } else if (p === '4') {
                        styles.push('text-decoration:underline');
                    } else if (colors[p]) {
                        styles.push('color:' + colors[p]);
                    }
                }

                return styles.length > 0 ? `<span style="${styles.join(';')}">` : '';
            });

            return html;
        }

    </script>

    <!-- API Client and Terminal Manager -->
    <script src="static/api-client.js"></script>
    <script src="static/terminal.js"></script>
</body>

</html>